#+TITLE: Jvm 高级

* DONE 自动内存管理
** DONE 运行时数据区
有五大运行时数据区
*** 程序记数器
- 字节码行号
- 线程唯一
- 本地方法为空
- 不会内存耗尽
*** 虚拟机栈
- 线程私有
- 局部变量表，最重要的一块
*** 本地方法栈
*** 堆
- 需要垃圾收集
- 分代只是垃圾收集的概念，并非虚拟机本身的概念
- 大多可扩展，内存耗尽并且堆无法扩展时，会抛内存耗尽错误
*** 方法区
- 非堆
- 线程共享
- 常量池
  具备一定的动态性
*** 直接内存
不属于运行时数据区，但是也被频繁使用。
比如 NIO 的缓冲区
** DONE 对象创建
*** 对象分配方式
- 指针碰撞
  对象比较规整的放在一起时，直接从后面分一块内存
  + 线程安全
    - CAS 加上失败重试来保证操作的原子性
    - 每个线程分配一个独立区域 TLAB
- 空闲列表
  对象比较杂乱时，维护一个表时的创建方式
*** 对象的内存布局
**** 对象头
***** Mark Word
***** 类型指针
**** 实例数据
先长后短，节省内存
**** 对齐填充
*** 对象的访问定位
**** 句柄访问
访问性能低一些，但是
**** 直接指针访问
访问性能优于前者， HS 用的是前者
** DONE 实战：内存不足错误
*** DONE 堆溢出
创建一大堆对象，或者内存泄漏。
**** DONE 参数
-Xms
-Xmx
*** DONE 栈溢出
无穷递归
线程创建过多
**** DONE 参数
-Xss
*** DONE 元空间、常量池溢出
**** 常量池溢出
jdk7 之前是在方法区，之后实现放在了堆中，可以被 FullGC 回收
**** 方法区溢出
方法区溢出通过 CGLIB 在运行时动态创建过多的类导致
当前许多框架
**** 参数
-XX:MetaspaceSize
-XX:MaxMetaspaceSize
-XX:MinMetaspaceFreeRatio
*** DONE 直接内存溢出
一个明显的特征就是 Heap Dump 的文件比较小，没有什么明显的异常。
并且程序使用了 NIO 等使用了 DirectMemory 的话。就必须重视直接内存了。
* TODO 垃圾收集
垃圾回收需要解决的三个问题：
- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？
** 对象已死？
*** 引用记数法
很有用，但是例外情况比较多，循环依赖问题无法解决， python 用这个
*** 可达性分析
Java lisp 等使用可达性分析算法来
**** GC Roots
  + 栈帧
  + 方法区静态属性
  + 常量
  + JNI
  + 虚拟机内部引用
  + 同步锁持有的对象
  + 本地代码缓存
*** 再谈引用
Java 引用的概念主要分为四种，这四种引用强度一次减弱：
- 强引用
  只要强引用关系存在，就一定不会被回收
- 软引用
  一些还有用，但是非必须的对象。
  在内存快溢出时，垃圾回收器会考虑将它回收
- 弱引用
  弱引用比软引用还弱，只能存活在下一次垃圾回收之前
- 虚引用
finalize 不建议用，在 9 里面已经标记为丢弃了
*** 回收方法区
方法区回收的性价比是比较低的，并且标记回收的判定条件比较苛刻。一般来说可回收的条件有
- 没有被引用的常量
- 实例被回收，类加载器被回收，class 对象没有被任何地方引用的类
在大量使用动态代理、反射、以及 CGLib 等字节码框架的场合，通常都会要求虚拟机具有卸载类的能力
** 垃圾回收算法
*** 分代收集理论
建立在两个分代假说之上：
1. 弱分代假说
   绝大多数对象都是朝生夕灭的
2. 强分代假说
   熬过越多次垃圾收集过程的对象越难以消灭
* TODO 虚拟机执行子系统
** DONE 类文件结构
*** 特点
- 平台中立
- 紧凑、稳定和可扩展
*** Class 类文件的结构
**** 编码的角度
- 二进制
- 8 位为一单位（这也是为什么叫字节码）
- 数据排列紧凑，无任何分隔符
**** 数据结构
- 由两种数据类型组成，整个 class 文件可以说就是一张表（好像 lua ）
  + 无符号数
    字节数 1 2 4 8 表示各种数据
  + 表
    表比较套娃，是由多个无符号数以及其他表作为数据项
***** 魔数头和版本
- 0xCAFEBABE
- u4 Java 版本号
***** 常量池
- u2 constant_pool_count 容量
  从 1 开始，可以用 0 表示不引用常量池
- 字面量
  + 文本字符串
  + final 常量值
- 符号引用
  Java 编译不进行连接操作，而是在加载 class 文件时进行动态连接，从常量池中获取符号引用
  + 类或接口的全名
  + 字段名称和描述符
  + 方法名称和描述符
***** 访问标志
- u1 类或者接口的访问信息
  + 类或接口
  + public
  + abstract
  + final
***** 类索引、父类索引、接口索引
这是用来确定继承和实现关系的索引
- u2 类索引
- u2 父类索引
- u2 一组接口索引
***** 字段表
- 访问标志
包含信息，访问信息，可见性，可序列化
- 简单名称
- 描述符
  + int[] [I
***** 方法表
- 访问标志
包含信息，访问信息，可见性，可序列化
- 简单名称
- 描述符
  + int[] get(int a) I[I
    先参数后返回值
****** 属性表
******* Exceptions
Java 使用异常表来在异常出现时跳转
******* SourceFile
******* InnerClass
******* Code
编译出来的指令
** TODO 类加载机制
类的加载、连接、初始化都在运行时进行的，提供了高度的灵活性，当然，牺牲了一些运行时性能。
*** 类加载时机
**** 类的生命周期
#+begin_src plantuml
@startuml
'https://plantuml.com/activity-diagram-beta

start
:Loading;
partition Linking {
:Verification;
:Preparation;
:Resolution;
}
:Initialization;
:Using;
:Unloading;
stop
@enduml
#+end_src
其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。
**** 初始化时机
Java 类的初始化分为主动初始化和被动初始化，
***** 主动初始化
- new getstatic putstatic invokestatic
- 反射调用时
- 初始化子类时如果父类没有初始化，那么父类进行初始化
  接口有点不一样，接口不会要求所有父接口都初始化，而只要求用到的接口初始化
- 虚拟机启动后的 main() 方法类
- java.lang.invoke.MethodHandle
***** 不初始化
- 子类引用父类的静态字段，不会导致子类初始化
- 通过数组定义来引用类，不会导致类的初始化
- 引用常量不会导致类的初始化
*** 类加载过程
**** 加载
获取字节流 -> 转化为方法区数据结构 -> 内存中生成 Class 对象，作为类的访问入口
***** 字节流获取方式
- ZIP
- Applet
- 运行时生成
- Proxy
- JSP
- 数据库读取

** TODO 字节码执行引擎
** TODO 案例实战：自己动手实现远程执行
* HOLD 程序编译与代码优化
* HOLD 高效并发
