#+TITLE: Jvm 高级

* HOLD 自动内存管理
* TODO 虚拟机执行子系统
** TODO 类文件结构
*** 特点
- 平台中立
- 紧凑、稳定和可扩展
*** Class 类文件的结构
**** 编码的角度
- 二进制
- 8 位为一单位（这也是为什么叫字节码）
- 数据排列紧凑，无任何分隔符
**** 数据结构
- 由两种数据类型组成，整个 class 文件可以说就是一张表（好像 lua ）
  + 无符号数
    字节数 1 2 4 8 表示各种数据
  + 表
    表比较套娃，是由多个无符号数以及其他表作为数据项
***** 魔数头和版本
- 0xCAFEBABE
- u4 Java 版本号
***** 常量池
- u2 constant_pool_count 容量
  从 1 开始，可以用 0 表示不引用常量池
- 字面量
  + 文本字符串
  + final 常量值
- 符号引用
  Java 编译不进行连接操作，而是在加载 class 文件时进行动态连接，从常量池中获取符号引用
  + 类或接口的全名
  + 字段名称和描述符
  + 方法名称和描述符
***** 访问标志
- u1 类或者接口的访问信息
  + 类或接口
  + public
  + abstract
  + final
***** 类索引、父类索引、接口索引
这是用来确定继承和实现关系的索引
- u2 类索引
- u2 父类索引
- u2 一组接口索引
***** 字段表
- 访问标志
包含信息，访问信息，可见性，可序列化
- 简单名称
- 描述符
  + int[] [I
***** 方法表
- 访问标志
包含信息，访问信息，可见性，可序列化
- 简单名称
- 描述符
  + int[] get(int a) I[I
    先参数后返回值
****** 属性表
******* Exceptions
Java 使用异常表来在异常出现时跳转
******* SourceFile
******* InnerClass
******* Code
编译出来的指令
** TODO 类加载机制
类的加载、连接、初始化都在运行时进行的，提供了高度的灵活性，当然，牺牲了一些运行时性能。
*** 类加载时机
**** 类的生命周期
#+begin_src plantuml
@startuml
'https://plantuml.com/activity-diagram-beta

start
:Loading;
partition Linking {
:Verification;
:Preparation;
:Resolution;
}
:Initialization;
:Using;
:Unloading;
stop
@enduml
#+end_src
其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。
**** 初始化时机
Java 类的初始化分为主动初始化和被动初始化，
***** 主动初始化
- new getstatic putstatic invokestatic
- 反射调用时
- 初始化子类时如果父类没有初始化，那么父类进行初始化
  接口有点不一样，接口不会要求所有父接口都初始化，而只要求用到的接口初始化
- 虚拟机启动后的 main() 方法类
- java.lang.invoke.MethodHandle
***** 被动初始化
- 子类引用父类的静态字段，不会导致子类初始化
- 通过数组定义来引用类，不会导致类的初始化
- 引用常量不会导致类的初始化
*** 类加载过程
**** 加载
获取字节流 -> 转化为方法区数据结构 -> 内存中生成 Class 对象，作为类的访问入口
***** 字节流获取方式
- ZIP
- Applet
- 运行时生成
- Proxy
- JSP
- 数据库读取

** TODO 字节码执行引擎
** TODO 案例实战：自己动手实现远程执行
* HOLD 程序编译与代码优化
* HOLD 高效并发
